C51 COMPILER V8.01   TIMER_04_VASILENKO                                                    11/27/2013 10:54:03 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE TIMER_04_VASILENKO
OBJECT MODULE PLACED IN Timer_04_vasilenko.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil3\C51\BIN\C51.EXE Timer_04_vasilenko.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //======================================================================================
   2          //               Timer_04
   3          //  Name: Jurij         Vorname: Vasilenko        Klasse: ITAM2     Datum: 26. Nov 2013                   
             -                                               
   4          //======================================================================================
   5          //******************************* Quelltextdateien *************************************
   6          #include <Reg515c.h>            // Definition der Port-Bytes usw.
   7          //********************************** Konstanten ****************************************
   8          sbit P4_0 = P4^0;
   9          sbit P5_0 = P5^0;
  10          //****************************** Funktionsdeklarationen ********************************
  11          void main(void);
  12          void init_seriell(void);
  13          void putchar(char ch);
  14          void printstring(char *cp);
  15          char getchar(void);
  16          void init_timer0(void);
  17          void printuintdez(unsigned int x);
  18          //******************************** Hauptprogramm ***************************************
  19          unsigned int count, sec, z0start=256-500/6;
  20          unsigned char vorwahl, pin, maske;
  21          //---------------------------------------------------------------------------------------
  22          void main(void)
  23          {
  24   1        if(BD == 0) // Baudratengenerator noch nicht aktiv
  25   1         init_seriell();  // serielle Kommunikation ermöglichen
  26   1        init_timer0();  // Timer 0 initialisieren
  27   1        EAL=1;  // Interrupts generell freigegeben
  28   1            
  29   1        while(1)  // Endlos 
  30   1        {
  31   2        maske=0x01;
  32   2          sec=0;  // Sec reset
  33   2          printstring("Vorwahl: ");  // Eingabeaufforderung
  34   2          vorwahl=getchar();  // Einlesen
  35   2          putchar(vorwahl);  // Echo
  36   2          vorwahl=vorwahl-'0';  // ASCII Konvertierung
  37   2          putchar('\n');
  38   2          printstring("Portpin: ");  // Portpin Eingabeaufforderung
  39   2          pin=getchar();  // Einlesen
  40   2          putchar(pin);
  41   2          pin-=0x30;  // ASCII Konvertierung
  42   2          maske=maske<<pin;  // Pin in maske schieben
  43   2          putchar('\n');
  44   2          printstring("Adresse Maske: ");
  45   2          printuintdez(maske);
  46   2          putchar('\n');
  47   2          printstring("Adresse Pin: ");
  48   2          printuintdez(pin); 
  49   2          putchar('\n');                
  50   2          P5=P5&~maske;  // LED an   
  51   2          TR0=1;  // Timer0 starten
  52   2          while(vorwahl!=sec);  // Warten bis die Zeit erreicht wurde
  53   2          P5=P5|maske;  // LED aus
  54   2          TR0=0;  // Timer 0 stoppen
C51 COMPILER V8.01   TIMER_04_VASILENKO                                                    11/27/2013 10:54:03 PAGE 2   

  55   2        }
  56   1      }
  57          //***************************** F u n k t i o n e n ************************************
  58          void init_seriell(void) 
  59          {
  60   1        SCON  = 0x50;  // SCON: mode 1, 8-bit UART, enable rcvr 
  61   1        PCON |= 0x80;  // SMOD Bit setzen 
  62   1        SRELH = 0x03;  // 9600 baud @ 10MHz für C515C
  63   1        SRELL = 0xBF;
  64   1        BD    = 1;  // Baudratengenerator verwenden
  65   1        TI    = 1;  // TI:   "vorausgegangenes Transmit" beendet
  66   1      }
  67          //---------------------------------------------------------------------------------------
  68          void putchar(char ch)
  69          {
  70   1        while(TI != 1);  // voriges Transmit Ende abwarten
  71   1        TI=0;  // für nächste Übertragung löschen
  72   1        SBUF=ch;  // Byte der Variablen ch seriell senden
  73   1      }
  74          //---------------------------------------------------------------------------------------
  75          void printstring(char *cp)
  76          {
  77   1        for(; *cp != '\0'; cp++)
  78   1          putchar(*cp);   // Zeichen seriell ausgeben
  79   1      }
  80          //---------------------------------------------------------------------------------------
  81          char getchar(void)
  82          {
  83   1        char cget;
  84   1      
  85   1        do{  
  86   2          while(!RI);  // Receive Ende abwarten (in dScope Serial Window TASTENDRUCK!)
  87   2          cget=SBUF;  // seriell empfangenes Byte in Variable cget übernehmen
  88   2          RI=0;  // Meldung: kann neue Daten empfangen
  89   2          }while(cget==0x11);
  90   1        return(cget);
  91   1      }
  92          //---------------------------------------------------------------------------------------
  93          void init_timer0(void)
  94          {
  95   1        TMOD=TMOD&0xF0;  // Timer 0
  96   1        TMOD=TMOD|0x02;  // Modus 2  
  97   1        TL0=z0start;  // Low Anteil übertragen
  98   1        TH0=z0start;  // High Anteil übertragen
  99   1        TF0=0;  // Flags löschen
 100   1        ET0=1;  // Interrupt freigeben
 101   1      }
 102          //---------------------------------------------------------------------------------------
 103          void printuintdez(unsigned int x)
 104          {
 105   1        putchar(x%100000/10000+'0');
 106   1        putchar(x%10000/1000+'0');
 107   1        putchar(x%1000/100+'0');
 108   1        putchar(x%100/10+'0');
 109   1        putchar(x%10+'0');
 110   1      }
 111          //--------------------------------- Interrupt -------------------------------------------
 112          void timer0_int(void)interrupt 1
 113          {
 114   1         count++;
 115   1         if(count==20000)  // 1 Sekunde vergangen
 116   1         {
C51 COMPILER V8.01   TIMER_04_VASILENKO                                                    11/27/2013 10:54:03 PAGE 3   

 117   2           sec++;  // Sekunde hochzählen
 118   2           count=0;  // count reset
 119   2         }
 120   1         P4_0=P4_0^1;  // Kontrolle
 121   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    395    ----
   CONSTANT SIZE    =     50    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
