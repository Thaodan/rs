C51 COMPILER V8.01   COUNTER_01_VASILENKO                                                  11/13/2013 10:27:39 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE COUNTER_01_VASILENKO
OBJECT MODULE PLACED IN Counter_01_Vasilenko.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil3\C51\BIN\C51.EXE Counter_01_Vasilenko.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //======================================================================================
   2          //               Counter_01
   3          //  Name: Jurij          Vorname: Vasilenko        Klasse: ITAM2     Datum: 6. Nov 2013                   
             -                                               
   4          //======================================================================================
   5          //******************************* Quelltextdateien *************************************
   6          #include <Reg515c.h>            // Definition der Port-Bytes usw.
   7          //********************************** Konstanten ****************************************
   8          sbit P4_0 = P4^0;
   9          //****************************** Funktionsdeklarationen ********************************
  10          void main(void);
  11          void printuintdez(unsigned int x);
  12          void init_seriell(void);
  13          void putchar(char ch);
  14          void printstring(char *stringanfang);
  15          char getchar(void);
  16          unsigned int getuintdez(void);
  17          void timer0_int(void);
  18          //******************************** Hauptprogramm ***************************************
  19          int start, c,count,countalt=0xFF;
  20          void main(void)
  21          {
  22   1        if(BD == 0)     // Baudratengenerator noch nicht aktiv
  23   1         init_seriell();    // serielle Kommunikation ermöglichen
  24   1        TMOD=TMOD&0xF0;
  25   1        TMOD=TMOD|0x05;
  26   1        TR0=1;  // Counter starten
  27   1        TF0=0;  // Überlaufflag löschen
  28   1        ET0=1;  // Interrupt freigeben
  29   1        EAL=1;  // Interrupts generell freigeben
  30   1        
  31   1        count=getuintdez();
  32   1        start=count;
  33   1        TL0=count;  // nur Low-Anteil übertragen
  34   1        TH0=count>>8; // high nach low schieben, dann übertragen
  35   1        countalt=count; // countalt auf count legen
  36   1            
  37   1        while(1)  // Endlos
  38   1        {
  39   2          count=(TH0<<8)|TL0; // Zählwert in count eintragen
  40   2          if(count!=countalt) // Zählwert hat sich verändert
  41   2          {
  42   3            countalt=count; // aktualisieren
  43   3            // putchar(count+'0'); // Zahlenbereich von 0..9
  44   3            printuintdez(count);
  45   3            putchar('\n');
  46   3          }
  47   2        }
  48   1      }
  49          //***************************** F u n k t i o n e n ************************************
  50          void printuintdez(unsigned int x)
  51          {
  52   1        putchar(x%100000/10000+'0');
  53   1        putchar(x%10000/1000+'0');
  54   1        putchar(x%1000/100+'0');
C51 COMPILER V8.01   COUNTER_01_VASILENKO                                                  11/13/2013 10:27:39 PAGE 2   

  55   1        putchar(x%100/10+'0');
  56   1        putchar(x%10+'0');
  57   1      }
  58          void init_seriell(void) 
  59            {
  60   1        SCON  = 0x50;   // SCON: mode 1, 8-bit UART, enable rcvr 
  61   1        PCON |= 0x80;         // SMOD Bit setzen 
  62   1        SRELH = 0x03;         // 9600 baud @ 10MHz für C515C
  63   1        SRELL = 0xBF;
  64   1        BD    = 1;    // Baudratengenerator verwenden
  65   1        TI    = 1;            // TI:   "vorausgegangenes Transmit" beendet
  66   1        }
  67          void putchar(char ch)
  68            {
  69   1        while(TI != 1); // voriges Transmit Ende abwarten
  70   1        TI=0;                 // für nächste Übertragung löschen
  71   1        SBUF=ch;    // Byte der Variablen ch seriell senden
  72   1        }
  73          void printstring(char *cp)
  74            {
  75   1        for(; *cp != '\0'; cp++)
  76   1             putchar(*cp);    // Zeichen seriell ausgeben
  77   1        }
  78          char getchar(void)
  79            {
  80   1        char cget;
  81   1      
  82   1        do{  
  83   2          while(!RI);           // Receive Ende abwarten (in dScope Serial Window TASTENDRUCK!)
  84   2          cget=SBUF;      // seriell empfangenes Byte in Variable cget übernehmen
  85   2          RI=0;     // Meldung: kann neue Daten empfangen
  86   2          }while(cget==0x11);
  87   1        return(cget);
  88   1        }
  89          unsigned int getuintdez(void)
  90          {
  91   1        printstring("Startwert: "); // Eingabeaufforderung
  92   1        c=getchar();
  93   1        putchar(c);
  94   1        c=c-'0';
  95   1        count=c*10000;
  96   1        c=getchar();
  97   1        putchar(c);
  98   1        c=c-'0';
  99   1        count=count+c*1000;
 100   1        c=getchar();
 101   1        putchar(c);
 102   1        c=c-'0';
 103   1        count=count+c*100;
 104   1        c=getchar();
 105   1        putchar(c);
 106   1        c=c-'0';
 107   1        count=count+c*10;
 108   1        c=getchar();
 109   1        putchar(c);
 110   1        c=c-'0';
 111   1        count=count+c;
 112   1        putchar('\n');
 113   1      
 114   1        return count;
 115   1      }
 116          void timer0_int()interrupt 1
C51 COMPILER V8.01   COUNTER_01_VASILENKO                                                  11/13/2013 10:27:39 PAGE 3   

 117          { 
 118   1        // TF0 wird durch Hardware zurückgesetzt
 119   1        TL0=start;  // nur Low-Anteil übertragen
 120   1        TH0=start>>8; // high nach low schieben, dann übertragen
 121   1        P4_0=P4_0^1;  // LED umschalten (toggle)
 122   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    489    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
