C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE LCD_02
OBJECT MODULE PLACED IN LCD_02.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil3\C51\BIN\C51.EXE LCD_02.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //---------------------------------------------------------------------------------------
   2          //    LCD am Datenbus des C515C mit Busy-Abfrage 
   3          //    alphanumerisches LCD EA DIP204-4NLED   20 Char x 4 Zeilen 
   4          //---------------------------------------------------------------------------------------
   5          //-------------------------------- Quelltextdateien -------------------------------------
   6          #include <Reg515c.h>
   7          //...........................Adress Spezifikationen......................................
   8          sbit    P1_0    =  P1^0;     // Signaleingang
   9          //-------------------------------- Symbolische Konstanten -------------------------------
  10          #define LCD_data3 ((unsigned char *)0x2FF00L) // /CS3   benutzter Adressbereich!
  11          #define LCD_data2 ((unsigned char *)0x2FE00L)   // /CS2
  12          #define LCD_data1 ((unsigned char *)0x2FD00L)   // /CS1
  13          //                                    ^          siehe Badischweiler  MC-Tools 7 S.60
  14          //                                  Speichertyp: 4=data,1=idata,3=pdata,2=xdata,5=code
  15          #define WRITE_INS   ((unsigned char *)0x2FF00L) // siehe Badischweiler\LCD Simulation
  16          #define READ_INS    ((unsigned char *)0x2FF01L) //  \LCD_demo\c51.de\Teil2
  17          #define WRITE_DATA  ((unsigned char *)0x2FF02L) //  \Software\LCD\LCD_Example\lcd_def.h
  18          #define READ_DATA   ((unsigned char *)0x2FF03L) // A1-->RS   A0-->R/W
  19          #define ENTER 0x0D
  20          //-------------------------------- Adress Spezifikationen -------------------------------
  21          sbit    P3_2    =  P3^2;        // P3.2  Taster blau
  22          //-------------------------------- globale Variablen ------------------------------------
  23          int position,c,i,hex=0,hex1,z;  // 0..1..80
  24          //-------------------------------- P r o t o t y p e n ----------------------------------
  25          void main(void);
  26          void init_seriell(void);
  27          void init_lcd(void);
  28          void wait(unsigned char ms);// wartet 0..255 ms
  29          char waitbsy(void);     // wartet bis Busy Flag gelöscht, Rückgabe Adresse DD oder CG
  30          void gotozs(unsigned char z, unsigned char s);
  31          void putlcd(char ch);
  32          //void printlcd(char *stringanfang);
  33          void printstring(char *stringanfang);
  34          void printbytedez(unsigned char zahl);    
  35          void putchar(char ch);
  36          char getchar(void);
  37          unsigned int spalte=19,stellen,hexzeile=19;
  38          //unsigned int getuintdez(void);
  39          //------------------------------ H a u p t p r o g r a m m ------------------------------
  40          void main(void) 
  41            {
  42   1          if(BD == 0)
  43   1            init_seriell();
  44   1          init_lcd();                   // LCD 4 Zeilen init
  45   1          EAL=1;  
  46   1        
  47   1          putchar('\n');
  48   1          printstring("Ihre Dualzahl: \n");    
  49   1          gotozs(0,spalte); 
  50   1          while(1)                       
  51   1          {
  52   2            static int s=1; 
  53   2            static int s1=1;
  54   2            static int s2=0;  
  55   2            if(spalte==0)
C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 2   

  56   2              spalte=19;
  57   2            c=getchar();
  58   2            s2=s2+1;
  59   2            if(c=='1'||c=='0')
  60   2            {   
  61   3              if(c=='1')
  62   3              { 
  63   4                z=z+s;
  64   4                hex=hex+s1;
  65   4                if(hex==10)
  66   4                {
  67   5                  hex1='A';
  68   5                }
  69   4                if(hex==11)
  70   4                {
  71   5                  hex1='B';
  72   5                }
  73   4                if(hex==12)
  74   4                {
  75   5                  hex1='C';
  76   5                }
  77   4                if(hex==13)
  78   4                {
  79   5                  hex1='D';
  80   5                }
  81   4                if(hex==14)
  82   4                {
  83   5                  hex1='E';
  84   5                } 
  85   4                if(hex==15)
  86   4                {
  87   5                hex1='F';
  88   5                }
  89   4              }
  90   3          
  91   3          putchar(c);
  92   3          putlcd(c);
  93   3          gotozs(0,spalte); 
  94   3          spalte=spalte-1;
  95   3          } 
  96   2          gotozs(1,19);
  97   2        
  98   2          if(z<=99&&z>=10)
  99   2          {
 100   3          putlcd('\b');
 101   3          }
 102   2          if(z>=100)
 103   2          {
 104   3          putlcd('\b');
 105   3          putlcd('\b');
 106   3          }
 107   2          printbytedez(z);
 108   2          gotozs(2,hexzeile);
 109   2          if(s2<4)
 110   2          {
 111   3          if(hex<10)
 112   3          {
 113   4          putlcd(hex+'0');
 114   4        
 115   4          }
 116   3          if(hex>9&&hex<15)
 117   3          {
C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 3   

 118   4            putlcd(hex1); 
 119   4          
 120   4          }} 
 121   2          if(s2==4) 
 122   2          { s2=0;
 123   3            
 124   3            if(hex<10)    
 125   3            putlcd(hex+'0');
 126   3            if(hex>9)
 127   3            putlcd(hex1); 
 128   3            hex=0;
 129   3            hexzeile=hexzeile-1;
 130   3          }
 131   2          gotozs(0,spalte);
 132   2            s=s*2;
 133   2          s1=s1*2;
 134   2          if(hex==0)
 135   2          {
 136   3          s1=1;
 137   3          }
 138   2          }
 139   1        for(;;);  // endlos
 140   1         }
 141          //---------------------------------------------------------------------------------------
 142          void init_lcd(void)
 143            {
 144   1        wait(15);         // nach Power ON erforderlich
 145   1        *WRITE_INS=0x34;  // Function Set: 8 Bit, RE=1
 146   1        wait(1);    // erforderlich 39µs
 147   1        *WRITE_INS=0x09;  // extended Function Set: 4 Zeilen Modus
 148   1        wait(1);    // erforderlich 39µs
 149   1        *WRITE_INS=0x30;  // 8 Bit, RE=0, no low power 
 150   1        wait(1);    // erforderlich 39µs
 151   1        *WRITE_INS=0x0F;  // Display ein, Cursor ein, Cursor blinken
 152   1        wait(1);    // erforderlich 39µs
 153   1        *WRITE_INS=0x01;  // Display löschen, Cursor auf 1.Spalte von 1.Zeile
 154   1        wait(2);          // erforderlich 1530µs
 155   1        *WRITE_INS=0x06;  // Entry Mode Set: Cursor Auto-Increment
 156   1        wait(1);    // erforderlich 39µs
 157   1        }
 158          //---------------------------------------------------------------------------------------
 159          void wait(unsigned char ms)
 160            {
 161   1        unsigned int t;
 162   1      
 163   1        while(ms > 0)
 164   1          {
 165   2          for(t=210; t>0; t--);
 166   2          ms--;
 167   2          }
 168   1        }
 169          //---------------------------------------------------------------------------------------
 170          char waitbsy(void)
 171            {
 172   1        char bsy_adr;     // Vorzeichen Bit ist Busy Flag
 173   1      
 174   1        while(1)
 175   1          {
 176   2          bsy_adr=*READ_INS;    // Busy Flag und Adresse lesen
 177   2          if((bsy_adr&0x80) == 0) // Busy Flag gelöscht
 178   2            break;
 179   2          }
C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 4   

 180   1        return bsy_adr;   // 7:bsy,  6..0 RAM Adress
 181   1        }
 182          //---------------------------------------------------------------------------------------
 183          void gotozs(unsigned char z, unsigned char s)
 184            {
 185   1        z=(z+s/20)%4;     // auch mit z>3 und s>19 nutzbar
 186   1        s=s%20;
 187   1        position=z*20+s;
 188   1        *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 189   1        waitbsy();                // warten bis Busy Flag gelöscht
 190   1        }
 191          //---------------------------------------------------------------------------------------
 192          void putlcd(char ch)
 193            {
 194   1        if(ch != 0x0D && ch != '\b' && ch != '\t')
 195   1          {
 196   2          *WRITE_DATA=ch;
 197   2          waitbsy();      // warten bis Busy Flag gelöscht
 198   2          position=++position%80;       // neue Cursorposition
 199   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 200   2          waitbsy();            // warten bis Busy Flag gelöscht
 201   2          return;
 202   2          }
 203   1        if(ch == 0x0D)
 204   1          {
 205   2          if(position/20 == 0)
 206   2            position=20;
 207   2          else if(position/20 == 1)
 208   2            position=40;
 209   2          else if(position/20 == 2)
 210   2            position=60;
 211   2          else if(position/20 == 3)
 212   2            position=0;
 213   2          }
 214   1        if(ch == '\b'  && position%20 != 0)
 215   1          {
 216   2          position--;
 217   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 218   2          waitbsy();            // warten bis Busy Flag gelöscht
 219   2          *WRITE_DATA=' ';
 220   2          waitbsy();        // warten bis Busy Flag gelöscht
 221   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 222   2          waitbsy();            // warten bis Busy Flag gelöscht
 223   2          return;
 224   2          }
 225   1        if(ch == '\t')
 226   1          {
 227   2          if(position >= 70)      // am Ende
 228   2            position=0;
 229   2          else if(position%20 < 10)
 230   2            position=position/20*20+10; // in derselben Zeile
 231   2          else
 232   2            position=(position/20+1)*20;  // in der nächsten Zeile
 233   2          }
 234   1        *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 235   1        waitbsy();            // warten bis Busy Flag gelöscht
 236   1        }
 237          //---------------------------------------------------------------------------------------
 238          void init_seriell(void) 
 239            {
 240   1        SCON  = 0x50;     // SCON: mode 1, 8-bit UART, enable rcvr
 241   1        PCON |= 0x80;           // SMOD Bit setzen
C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 5   

 242   1        SRELH = 0x03;           // 9600 baud @ 10MHz für C515C entspricht
 243   1        SRELL = 0xBF;     // dScope COMMAND: XTAL=20000000  (80515A)
 244   1        BD    = 1;      // Baudratengenerator verwenden
 245   1        TI    = 1;              // TI:   "vorausgegangenes Transmit" beendet
 246   1        }
 247          //---------------------------------------------------------------------------------------
 248          void putchar(char ch)
 249            {
 250   1        while(TI != 1);   // voriges Transmit Ende abwarten
 251   1        TI=0;                   // für nächste Übertragung löschen
 252   1        SBUF=ch;      // Byte seriell senden
 253   1        }
 254          //---------------------------------------------------------------------------------------
 255          void printstring(char *cp)
 256            {
 257   1        for(; *cp != '\0'; cp++)
 258   1          putchar(*cp);
 259   1        }
 260          //---------------------------------------------------------------------------------------
 261          /*
 262          void printlcd(char *cp)
 263            {
 264            for(; *cp != '\0'; cp++)
 265              putlcd(*cp);
 266            }
 267          */
 268          //---------------------------------------------------------------------------------------
 269          void printbytedez(unsigned char zahl)
 270            {
 271   1        
 272   1        if(zahl<100000)
 273   1        stellen=5;
 274   1        if(zahl<10000)
 275   1          stellen=4;
 276   1        if(zahl<1000)
 277   1          stellen=3;
 278   1        if(zahl<100)
 279   1          stellen=2;
 280   1        if(zahl<10)
 281   1          stellen=1;
 282   1        if(stellen>3)
 283   1        putlcd(zahl%10000/1000 + '0');        // ASCII seriell ausgeben
 284   1        if(stellen>2)
 285   1        putlcd(zahl%1000/100 + '0');        // ASCII seriell ausgeben
 286   1        if(stellen>1)
 287   1        putlcd(zahl%100/10 + '0');        // ASCII seriell ausgeben
 288   1        if(stellen>0)
 289   1        putlcd(zahl%10 + '0');        // ASCII seriell ausgeben
 290   1        } 
 291          //---------------------------------------------------------------------------------------
 292          char getchar(void)
 293            {
 294   1        char cget;
 295   1      
 296   1        do{  
 297   2          while(!RI);           // Receive Ende abwarten (in dScope Serial Window TASTENDRUCK!)
 298   2          cget=SBUF;      // seriell empfangenes Byte in Variable cget übernehmen
 299   2          RI=0;     // Meldung: kann neue Daten empfangen
 300   2          }while(cget==0x11);
 301   1        return(cget);
 302   1        }
 303          //---------------------------------------------------------------------------------------
C51 COMPILER V8.01   LCD_02                                                                01/15/2014 10:09:10 PAGE 6   

 304          /*
 305          unsigned int getuintdez(void)
 306            {
 307            int wert=0;
 308            char c;
 309          
 310            while(1)
 311              {
 312              c=getchar();
 313              if(c == ENTER)
 314                break;
 315              putchar(c);
 316              wert=wert*10+c-'0';
 317              }
 318            return(wert);
 319            }
 320          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1181    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
