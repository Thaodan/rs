C51 COMPILER V8.01   LCD_02                                                                01/22/2014 09:01:00 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE LCD_02
OBJECT MODULE PLACED IN LCD_02.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil3\C51\BIN\C51.EXE LCD_02.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //---------------------------------------------------------------------------------------
   2          //    LCD am Datenbus des C515C mit Busy-Abfrage 
   3          //    alphanumerisches LCD EA DIP204-4NLED   20 Char x 4 Zeilen
   4          //--jak13--------------------------------------------------------------------------------
   5          //-------------------------------- Quelltextdateien -------------------------------------
   6          #include <Reg515c.h>
   7          //...........................Adress Spezifikationen......................................
   8          sbit    P1_0    =  P1^0;     // Signaleingang
   9          //-------------------------------- Symbolische Konstanten -------------------------------
  10          #define LCD_data3 ((unsigned char *)0x2FF00L) // /CS3   benutzter Adressbereich!
  11          #define LCD_data2 ((unsigned char *)0x2FE00L)   // /CS2
  12          #define LCD_data1 ((unsigned char *)0x2FD00L)   // /CS1
  13          //                                    ^          siehe Badischweiler  MC-Tools 7 S.60
  14          //                                  Speichertyp: 4=data,1=idata,3=pdata,2=xdata,5=code
  15          #define WRITE_INS   ((unsigned char *)0x2FF00L) // siehe Badischweiler\LCD Simulation
  16          #define READ_INS    ((unsigned char *)0x2FF01L) //  \LCD_demo\c51.de\Teil2
  17          #define WRITE_DATA  ((unsigned char *)0x2FF02L) //  \Software\LCD\LCD_Example\lcd_def.h
  18          #define READ_DATA   ((unsigned char *)0x2FF03L) // A1-->RS   A0-->R/W
  19          #define ENTER 0x0D
  20          //-------------------------------- Adress Spezifikationen -------------------------------
  21          sbit    P3_2    =  P3^2;        // P3.2  Taster blau
  22          //-------------------------------- globale Variablen ------------------------------------
  23          unsigned char position,c,i,hex=0,hex1,z;  // 0..1..80
  24          //-------------------------------- P r o t o t y p e n ----------------------------------
  25          void main(void);
  26          void init_seriell(void);
  27          void init_lcd(void);
  28          void wait(unsigned char ms);// wartet 0..255 ms
  29          char waitbsy(void);     // wartet bis Busy Flag gelöscht, Rückgabe Adresse DD oder CG
  30          void gotozs(unsigned char z, unsigned char s);
  31          void putlcd(char ch);
  32          //void printlcd(char *stringanfang);
  33          void printstring(char *stringanfang);
  34          //void printbytedez(unsigned char zahl);    
  35          void putchar(char ch);
  36          char getchar(void);
  37          unsigned int spalte=19,stellen,hexzeile=19,balkenspalte=19,a;
  38          unsigned int getuintdez(void);
  39          //------------------------------ H a u p t p r o g r a m m ------------------------------
  40          void main(void) 
  41            {
  42   1        
  43   1        if(BD == 0)
  44   1          init_seriell();
  45   1        init_lcd();                   // LCD 4 Zeilen init
  46   1        EAL=1;  
  47   1        
  48   1        printstring("Ihre Zahl: \n");    
  49   1        gotozs(0,spalte); 
  50   1        while(1)                       
  51   1        { 
  52   2          balkenspalte=19;
  53   2          if(spalte==0)
  54   2            spalte=19;
  55   2          a=getuintdez();
C51 COMPILER V8.01   LCD_02                                                                01/22/2014 09:01:00 PAGE 2   

  56   2      
  57   2          gotozs(0,19);
  58   2          putlcd(a+'0');
  59   2          putchar('\n');
  60   2          
  61   2          while(a>0)
  62   2          { 
  63   3            gotozs(3,balkenspalte); 
  64   3            if(a<5)
  65   3            {
  66   4              putlcd(a+'0');
  67   4              a=0;
  68   4            }
  69   3              if(a>=5)
  70   3            { putlcd('5');
  71   4              a=a-5;
  72   4            }
  73   3            balkenspalte=balkenspalte-1;
  74   3          } 
  75   2        }
  76   1      }
  77          //---------------------------------------------------------------------------------------
  78          void init_lcd(void)
  79            {
  80   1        wait(15);         // nach Power ON erforderlich
  81   1        *WRITE_INS=0x34;  // Function Set: 8 Bit, RE=1
  82   1        wait(1);    // erforderlich 39µs
  83   1        *WRITE_INS=0x09;  // extended Function Set: 4 Zeilen Modus
  84   1        wait(1);    // erforderlich 39µs
  85   1        *WRITE_INS=0x30;  // 8 Bit, RE=0, no low power 
  86   1        wait(1);    // erforderlich 39µs
  87   1        *WRITE_INS=0x0F;  // Display ein, Cursor ein, Cursor blinken
  88   1        wait(1);    // erforderlich 39µs
  89   1        *WRITE_INS=0x01;  // Display löschen, Cursor auf 1.Spalte von 1.Zeile
  90   1        wait(2);          // erforderlich 1530µs
  91   1        *WRITE_INS=0x06;  // Entry Mode Set: Cursor Auto-Increment
  92   1        wait(1);    // erforderlich 39µs
  93   1        }
  94          //---------------------------------------------------------------------------------------
  95          void wait(unsigned char ms)
  96            {
  97   1        unsigned int t;
  98   1      
  99   1        while(ms > 0)
 100   1          {
 101   2          for(t=210; t>0; t--);
 102   2          ms--;
 103   2          }
 104   1        }
 105          //---------------------------------------------------------------------------------------
 106          char waitbsy(void)
 107            {
 108   1        char bsy_adr;     // Vorzeichen Bit ist Busy Flag
 109   1      
 110   1        while(1)
 111   1          {
 112   2          bsy_adr=*READ_INS;    // Busy Flag und Adresse lesen
 113   2          if((bsy_adr&0x80) == 0) // Busy Flag gelöscht
 114   2            break;
 115   2          }
 116   1        return bsy_adr;   // 7:bsy,  6..0 RAM Adress
 117   1        }
C51 COMPILER V8.01   LCD_02                                                                01/22/2014 09:01:00 PAGE 3   

 118          //---------------------------------------------------------------------------------------
 119          void gotozs(unsigned char z, unsigned char s)
 120            {
 121   1        z=(z+s/20)%4;     // auch mit z>3 und s>19 nutzbar
 122   1        s=s%20;
 123   1        position=z*20+s;
 124   1        *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 125   1        waitbsy();                // warten bis Busy Flag gelöscht
 126   1        }
 127          //---------------------------------------------------------------------------------------
 128          void putlcd(char ch)
 129            {
 130   1        if(ch != 0x0D && ch != '\b' && ch != '\t')
 131   1          {
 132   2          *WRITE_DATA=ch;
 133   2          waitbsy();      // warten bis Busy Flag gelöscht
 134   2          position=++position%80;       // neue Cursorposition
 135   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 136   2          waitbsy();            // warten bis Busy Flag gelöscht
 137   2          return;
 138   2          }
 139   1        if(ch == 0x0D)
 140   1          {
 141   2          if(position/20 == 0)
 142   2            position=20;
 143   2          else if(position/20 == 1)
 144   2            position=40;
 145   2          else if(position/20 == 2)
 146   2            position=60;
 147   2          else if(position/20 == 3)
 148   2            position=0;
 149   2          }
 150   1        if(ch == '\b'  && position%20 != 0)
 151   1          {
 152   2          position--;
 153   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 154   2          waitbsy();            // warten bis Busy Flag gelöscht
 155   2          *WRITE_DATA=' ';
 156   2          waitbsy();        // warten bis Busy Flag gelöscht
 157   2          *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 158   2          waitbsy();            // warten bis Busy Flag gelöscht
 159   2          return;
 160   2          }
 161   1        if(ch == '\t')
 162   1          {
 163   2          if(position >= 70)      // am Ende
 164   2            position=0;
 165   2          else if(position%20 < 10)
 166   2            position=position/20*20+10; // in derselben Zeile
 167   2          else
 168   2            position=(position/20+1)*20;  // in der nächsten Zeile
 169   2          }
 170   1        *WRITE_INS=0x80|(position/20*32+position%20); // Cursor auf Position
 171   1        waitbsy();            // warten bis Busy Flag gelöscht
 172   1        }
 173          //---------------------------------------------------------------------------------------
 174          void init_seriell(void) 
 175            {
 176   1        SCON  = 0x50;     // SCON: mode 1, 8-bit UART, enable rcvr
 177   1        PCON |= 0x80;           // SMOD Bit setzen
 178   1        SRELH = 0x03;           // 9600 baud @ 10MHz für C515C entspricht
 179   1        SRELL = 0xBF;     // dScope COMMAND: XTAL=20000000  (80515A)
C51 COMPILER V8.01   LCD_02                                                                01/22/2014 09:01:00 PAGE 4   

 180   1        BD    = 1;      // Baudratengenerator verwenden
 181   1        TI    = 1;              // TI:   "vorausgegangenes Transmit" beendet
 182   1        }
 183          //---------------------------------------------------------------------------------------
 184          void putchar(char ch)
 185            {
 186   1        while(TI != 1);   // voriges Transmit Ende abwarten
 187   1        TI=0;                   // für nächste Übertragung löschen
 188   1        SBUF=ch;      // Byte seriell senden
 189   1        }
 190          //---------------------------------------------------------------------------------------
 191          void printstring(char *cp)
 192            {
 193   1        for(; *cp != '\0'; cp++)
 194   1          putchar(*cp);
 195   1        }
 196          //---------------------------------------------------------------------------------------
 197          /*
 198          void printlcd(char *cp)
 199            {
 200            for(; *cp != '\0'; cp++)
 201              putlcd(*cp);
 202            }
 203          */
 204          //---------------------------------------------------------------------------------------
 205          /*
 206          void printbytedez(unsigned char zahl)
 207            {
 208            
 209            if(zahl<100000)
 210            stellen=5;
 211            if(zahl<10000)
 212              stellen=4;
 213            if(zahl<1000)
 214              stellen=3;
 215            if(zahl<100)
 216              stellen=2;
 217            if(zahl<10)
 218              stellen=1;
 219            if(stellen>3)
 220            putlcd(zahl%10000/1000 + '0');        // ASCII seriell ausgeben
 221            if(stellen>2)
 222            putlcd(zahl%1000/100 + '0');        // ASCII seriell ausgeben
 223            if(stellen>1)
 224            putlcd(zahl%100/10 + '0');        // ASCII seriell ausgeben
 225            if(stellen>0)
 226            putlcd(zahl%10 + '0');        // ASCII seriell ausgeben
 227            }
 228           */ 
 229          //---------------------------------------------------------------------------------------
 230          char getchar(void)
 231            {
 232   1        char cget;
 233   1      
 234   1        do{  
 235   2          while(!RI);           // Receive Ende abwarten (in dScope Serial Window TASTENDRUCK!)
 236   2          cget=SBUF;      // seriell empfangenes Byte in Variable cget übernehmen
 237   2          RI=0;     // Meldung: kann neue Daten empfangen
 238   2          }while(cget==0x11);
 239   1        return(cget);
 240   1        }
 241          //---------------------------------------------------------------------------------------
C51 COMPILER V8.01   LCD_02                                                                01/22/2014 09:01:00 PAGE 5   

 242          unsigned int getuintdez(void)
 243            {
 244   1        int wert=0;
 245   1        char c;
 246   1      
 247   1        while(1)
 248   1          {
 249   2          c=getchar();
 250   2          if(c == ENTER)
 251   2            break;
 252   2          putchar(c);
 253   2          wert=wert*10+c-'0';
 254   2          }
 255   1        return(wert);
 256   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    604    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
