C51 COMPILER V8.01   TIMER_05_VASILENKO                                                    11/29/2013 12:41:50 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE TIMER_05_VASILENKO
OBJECT MODULE PLACED IN Timer_05_vasilenko.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil3\C51\BIN\C51.EXE Timer_05_vasilenko.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //=======================================================================================
   2          /*
   3            RS | Jakowsi | Hellweg Berufskolleg Unna
   4            Jurij Vasilenko | ITAM2 | 29. November 2013
   5            Timer_05
   6          */
   7          //=======================================================================================
   8          //******************************* Quelltextdateien *************************************
   9          #include <Reg515c.h>            // Definition der Port-Bytes usw.
  10          //********************************** Konstanten ****************************************
  11          sbit P4_0 = P4^0;
  12          sbit P5_0 = P5^0;
  13          //****************************** Funktionsdeklarationen ********************************
  14          void main(void);
  15          void init_seriell(void);
  16          void init_ad(void);
  17          void init_p33(void);
  18          void putchar(char ch);
  19          void printstring(char *cp);
  20          char getchar(void);
  21          void init_timer0(void);
  22          void printuintdez(unsigned int x);
  23          //******************************** Hauptprogramm ***************************************
  24          unsigned int count, sec, z0start=256-500/6;
  25          unsigned char vorwahl, pin, maske;
  26          unsigned int ad10bit;
  27          //---------------------------------------------------------------------------------------
  28          void main(void)
  29          {
  30   1        if(BD == 0) // Baudratengenerator noch nicht aktiv
  31   1         init_seriell();  // serielle Kommunikation ermöglichen
  32   1        init_timer0();  // Timer 0 initialisieren
  33   1        init_ad();
  34   1        init_p33();
  35   1        EAL=1;  // Interrupts generell freigegeben
  36   1            
  37   1        while(1)  // Endlos 
  38   1        {
  39   2          maske=0x01;
  40   2          sec=0;  // Sec reset
  41   2          printstring("Portpin: ");  // Portpin Eingabeaufforderung
  42   2          pin=getchar();  // Einlesen
  43   2          putchar(pin);
  44   2          putchar('\n');
  45   2          printstring("Vorwahl: ");  // Eingabeaufforderung
  46   2          ADDATL=1;
  47   2          while(BSY==1);
  48   2          vorwahl=ad10bit/100;
  49   2          printuintdez(vorwahl);
  50   2          putchar('s');
  51   2          pin-=0x30;  // ASCII Konvertierung
  52   2          maske=maske<<pin;  // Pin in maske schieben              
  53   2          P5=P5&~maske;  // LED an   
  54   2          TR0=1;  // Timer0 starten
  55   2          while(vorwahl!=sec);  // Warten bis die Zeit erreicht wurde
C51 COMPILER V8.01   TIMER_05_VASILENKO                                                    11/29/2013 12:41:50 PAGE 2   

  56   2          P5=P5|maske;  // LED aus
  57   2          TR0=0;  // Timer 0 stoppen
  58   2        }
  59   1      }
  60          //***************************** F u n k t i o n e n ************************************
  61          void init_seriell(void) 
  62          {
  63   1        SCON  = 0x50;  // SCON: mode 1, 8-bit UART, enable rcvr 
  64   1        PCON |= 0x80;  // SMOD Bit setzen 
  65   1        SRELH = 0x03;  // 9600 baud @ 10MHz für C515C
  66   1        SRELL = 0xBF;
  67   1        BD    = 1;  // Baudratengenerator verwenden
  68   1        TI    = 1;  // TI:   "vorausgegangenes Transmit" beendet
  69   1      }
  70          //---------------------------------------------------------------------------------------
  71          void putchar(char ch)
  72          {
  73   1        while(TI != 1);  // voriges Transmit Ende abwarten
  74   1        TI=0;  // für nächste Übertragung löschen
  75   1        SBUF=ch;  // Byte der Variablen ch seriell senden
  76   1      }
  77          //---------------------------------------------------------------------------------------
  78          void printstring(char *cp)
  79          {
  80   1        for(; *cp != '\0'; cp++)
  81   1          putchar(*cp);   // Zeichen seriell ausgeben
  82   1      }
  83          //---------------------------------------------------------------------------------------
  84          char getchar(void)
  85          {
  86   1        char cget;
  87   1      
  88   1        do{  
  89   2          while(!RI);  // Receive Ende abwarten (in dScope Serial Window TASTENDRUCK!)
  90   2          cget=SBUF;  // seriell empfangenes Byte in Variable cget übernehmen
  91   2          RI=0;  // Meldung: kann neue Daten empfangen
  92   2          }while(cget==0x11);
  93   1        return(cget);
  94   1      }
  95          //---------------------------------------------------------------------------------------
  96          void init_timer0(void)
  97          {
  98   1        TMOD=TMOD&0xF0;  // Timer 0
  99   1        TMOD=TMOD|0x02;  // Modus 2  
 100   1        TL0=z0start;  // Low Anteil übertragen
 101   1        TH0=z0start;  // High Anteil übertragen
 102   1        TF0=0;  // Flags löschen
 103   1        ET0=1;  // Interrupt freigeben
 104   1      }
 105          //---------------------------------------------------------------------------------------
 106          void printuintdez(unsigned int x)
 107          {
 108   1        putchar(x%100000/10000+'0');
 109   1        putchar(x%10000/1000+'0');
 110   1        putchar(x%1000/100+'0');
 111   1        putchar(x%100/10+'0');
 112   1        putchar(x%10+'0');
 113   1      }
 114          //--------------------------------- Interrupt -------------------------------------------
 115          void timer0_int(void)interrupt 1
 116          {
 117   1         count++;
C51 COMPILER V8.01   TIMER_05_VASILENKO                                                    11/29/2013 12:41:50 PAGE 3   

 118   1         if(count==20000)  // 1 Sekunde vergangen
 119   1         {
 120   2           sec++;  // Sekunde hochzählen
 121   2           count=0;  // count reset
 122   2         }
 123   1         P4_0=P4_0^1;  // Kontrolle
 124   1      }
 125          //---------------------------------------------------------------------------------------
 126          void init_ad(void)
 127          {
 128   1        EADC=0;
 129   1        IADC=0;
 130   1        ADM=0;
 131   1        ADEX=0;
 132   1        ADCON0&=0xF8;
 133   1        ADCON0|=0x03;
 134   1        ADCON1|=0x80;
 135   1        EADC=1;
 136   1      }
 137          //---------------------------------------------------------------------------------------
 138          void init_p33(void)
 139          {
 140   1        IT1=1;
 141   1        IE1=0;
 142   1        EX1=1;
 143   1      }
 144          //---------------------------------------------------------------------------------------
 145          void ad_int(void)interrupt 8
 146          {
 147   1        IADC=0;
 148   1        ad10bit=ADDATH<<8;
 149   1        ad10bit|=ADDATL;
 150   1        ad10bit>>=6;
 151   1      }
 152          //---------------------------------------------------------------------------------------
 153          void p33_int(void)interrupt 2
 154          {
 155   1        TR0=0;
 156   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    452    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
